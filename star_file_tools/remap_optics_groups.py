#!/usr/bin/env python3
## Author: A. Keszei

"""
    Take in a file with optics group assignments, e.g.:
        mic_01  optics_grp1
        ...
        mic_99  optics_grp10

    , and update an input RELION particle data.star file to generate a new optics table with all unique groups
    and each particle mapped to their new optics groups based on their micrograph assignment 
"""

## 2021-02-25: Wrote script & tested on mTRC dataset
## 2024-05-29: Adapted script to take in text tile generated by EPU_sort_by_beamshift.py 

#############################
#region     FLAGS
#############################
DEBUG = False

#endregion

#############################
#region     DEFINITION BLOCK
#############################

def usage():
    print("================================================================================================================")
    print(" Update the optics table and corresponding particle data based on an input file of the type:")
    print("      <filename>  <optics_group_name>")
    print("       ...")
    print(" Usage:")
    print("    $ remap_optics_groups.py  particles.star  shiftgroups.txt  ")
    print("================================================================================================================")
    sys.exit()

def parse_cmdline(cmdline):
    ## instantiate the parameters object to populate 
    params = PARAMETERS()

    ## cmd line minimally needs 3 inputs
    if len(cmdline) < 3:
        usage()

    ## first check for the help flag before proceeding 
    for i in range(len(cmdline)):
        if cmdline[i] in ['-h', '--h', '-H', '--H']:
            usage()
    
    ## iterate over every entry, looking for flags & files  
    for i in range(len(cmdline)):
        cmd = cmdline[i]

        ## look for a .star file 
        if len(cmd) > len('.star'):
            if cmd[-len('.star'):].lower() == '.star':
                params.assign_starfile(cmd)
        
        ## look for a .txt file 
        if len(cmd) > len('.txt'):
            if cmd[-len('.txt'):].lower() == '.txt':
                params.assign_optics_remap_file(cmd)



    return params

def parse_optics_remap_file(file):
    mic_to_optic_group = dict()
    unique_optics_groups = []
    with open(file, 'r') as f :
        for l in f:
            l = l.split()
            ## ignore comment lines
            if l[0][0] == "#":
                continue 
            else:
                mic = l[0]
                optics_grp = l[1]
                if mic in mic_to_optic_group:
                    print(" !! ERROR :: Micrograph (%s) has more than one optics group assignment in file (%s)" % (mic, file))
                    exit()
                else:
                    mic_to_optic_group[mic] = optics_grp
                    if optics_grp not in unique_optics_groups:
                        unique_optics_groups.append(optics_grp)
    try:
        unique_optics_groups = sorted(unique_optics_groups, key=int)
    except:
        unique_optics_groups = sorted(unique_optics_groups)
    return mic_to_optic_group, unique_optics_groups

def remap_optics_group(file, column_micName, column_opticsGroup, header_size, optics_value):
    """
    """
    with open(file, 'r') as f :
        lines = f.readlines()

    with open(file, 'w') as f :
        counter = 0 ## to get statistics on number of particles changed
        ## for overwriting a file see solution : https://stackoverflow.com/questions/41667617/how-to-overwrite-a-file-correctly
        for i in range(len(lines)):
            line_num = i + 1
            line = lines[i]
            ## copy the header into the new file
            if line_num <= header_size:
                f.write(line)
            ## ignore empty lines
            if len(line.strip()) == 0 :
                continue
            ## start working only after the header length
            if line_num > header_size:
                ## get the micrograph name
                mic_name = extract_mic_name(find_star_info(line, column_micName))
                ## check if the micrograph name matches the search criteria using a glob-style matchmaking
                if Path(mic_name).match(search_criteria):
                    counter += 1
                    if DEBUG and counter < 9: print(" >> search_criteria = %s ; match found = %s ; ... change optics group to: %s" % (search_criteria, mic_name, optics_value) )
                    ## on a match change the optics value in the correct column
                    new_line = line.split()
                    new_line[column_opticsGroup - 1] = optics_value ## change the column
                    f.write(' ' + '\t'.join(new_line) + '\n')
                else:
                    f.write(line)
    if DEBUG:
        print("...")
        print( "{:,}".format(counter) + " particle optical groups were updated")

def update_optics_table(file, out_file, optics_list):
    ## Get landmarks for optics data table so we can copy only this region 
    OPTICS_TABLE_START, OPTICS_HEADER_START, OPTICS_DATA_START, OPTICS_DATA_END = star_handler.get_table_position(file, 'data_optics', DEBUG = DEBUG)
    ## Get the particle data dimensions from input file (so we can faithfully copy the space between tables actually)
    PARTICLE_TABLE_START, PARTICLE_HEADER_START, PARTICLE_START, PARTICLE_END = star_handler.get_table_position(file, 'data_particles', DEBUG = DEBUG)

    
    ## Find columns for the relevant optics headers we need to change  
    COLUMN_rlnOpticsGroupName = star_handler.find_star_column(file, '_rlnOpticsGroupName', OPTICS_HEADER_START, OPTICS_DATA_START, DEBUG = DEBUG)
    COLUMN_rlnOpticsGroup = star_handler.find_star_column(file, '_rlnOpticsGroup', OPTICS_HEADER_START, OPTICS_DATA_START, DEBUG = DEBUG)

    with open(out_file, 'w') as s :

        with open(file, 'r') as f :
            line_num = 0
            for line in f :
                line_num += 1

                ## copy the leading header faithfully into the new file 
                if line_num < OPTICS_DATA_START:
                    s.write(line)
                    # print(" ..> ", line_num, line)

                ## get the first optics data entry as a template to make the new one we want 
                if line_num == OPTICS_DATA_START :
                    optics_entry = line.split()
                    for i in range(len(optics_list)):
                        optics_entry[COLUMN_rlnOpticsGroup - 1] = str(i + 1) 
                        optics_entry[COLUMN_rlnOpticsGroupName - 1] = str(optics_list[i])
                        ## create a nicely formatted string to print
                        formatted_string = ''
                        for n in optics_entry:
                            n += " "
                            formatted_string += '{:11}'.format(n)

                        s.write(formatted_string + "\n")
                
                ## copy the space after the optics table faithfully 
                if OPTICS_DATA_END < line_num < PARTICLE_TABLE_START:
                    s.write(line)
                        
    return 

def update_particles(file, out_file, optics_list, mic_to_optics_dict):
    ## Get the new optics table dimensions 
    OPTICS_TABLE_START, OPTICS_HEADER_START, OPTICS_DATA_START, OPTICS_DATA_END = star_handler.get_table_position(out_file, 'data_optics', DEBUG = DEBUG)
    ## Get the particle data dimensions from input file 
    PARTICLE_TABLE_START, PARTICLE_HEADER_START, PARTICLE_DATA_START, PARTICLE_DATA_END = star_handler.get_table_position(file, 'data_particles', DEBUG = DEBUG)

    ## Find columns for the relevant particle data entries we need to read or change  
    COLUMN_rlnMicrographName = star_handler.find_star_column(file, '_rlnMicrographName', PARTICLE_HEADER_START, PARTICLE_DATA_START, DEBUG = DEBUG)
    COLUMN_rlnOpticsGroup = star_handler.find_star_column(file, '_rlnOpticsGroup', PARTICLE_HEADER_START, PARTICLE_DATA_START, DEBUG = DEBUG)


    skipped_particles_count = 0
    updated_particles_count = 0
    with open(out_file, 'a') as s :
 
        with open(file, 'r') as f :
            line_num = 0
            for line in f :
                line_num += 1

                ## copy the particle header faithfully into the new file 
                if PARTICLE_DATA_START > line_num >= PARTICLE_TABLE_START : 
                    s.write(line)
                    # print(" ..> ", line_num, line)
                
                if PARTICLE_DATA_START <= line_num <= PARTICLE_DATA_END:
                    # print(" ..> ", line)
                    particle_data = line.split()
                    particle_micrograph_basename = os.path.splitext(os.path.basename(particle_data[COLUMN_rlnMicrographName - 1]))[0]

                    ## check if micrograph is found in the input remapping dictionary
                    MATCH_FOUND = False
                    for mic in list(mic_to_optics_dict): ## allow for fuzzy matching by using the keys are a list of strings we can compare against item-by-item 
                        ## in case there is something like _Fractions on one string and not the other, check only a string of similar length 
                        if len(particle_micrograph_basename) > len(mic):
                            particle_micrograph_basename = particle_micrograph_basename[:len(mic)]
                        if particle_micrograph_basename in mic: 
                            ## get the new optics group assignment for the discovered micrograph based on the input file 
                            updated_optics_group = mic_to_optics_dict[mic]
                            ## find the corresponding index for that optics group 
                            optics_index = optics_list.index(updated_optics_group) + 1 
                            ## update the optics group entry in the data line 
                            particle_data[COLUMN_rlnOpticsGroup - 1] = str(optics_index)
                            ## prepare the output string 
                            formatted_string = ''
                            for n in particle_data:
                                n += " " ## add a leading space in case the string is longer than the arbiray format delimiter 
                                formatted_string += '{:11}'.format(n)
                            ## write the new particle line in the output file 
                            s.write(formatted_string + "\n")
                            updated_particles_count += 1
                            print(f"\r Processing particle #%s" % updated_particles_count, end="")

                            MATCH_FOUND = True
                            break

                    if not MATCH_FOUND:
                        print(" !! WARNING :: Particle entry contains micrograph not present in remapping file (%s) -> %s, skipping ..." % (file, particle_micrograph_basename))
                        print(" Example comparison: ")
                        print("           Particle mic basename = ", particle_micrograph_basename)
                        print("    Example mic from optics file = ", list(mic_to_optics_dict)[0])
                        skipped_particles_count += 1
    print("")
    print("=====================================")
    print(" COMPLETE ")
    print("-------------------------------------")
    print("      %s particles updated " % updated_particles_count)
    if skipped_particles_count > 0:
        print("      %s particles skipped" % skipped_particles_count)
    print("-------------------------------------")
    print("  updated file written: %s" % out_file)
    print("=====================================")

    return 

class PARAMETERS():
    def __init__(self):
        self.optics_remap_file = ''
        self.star_file = ''
        self.output_star_file = ''

        return
    
    def assign_starfile(self, f):
        ## sanity check we did not already have a star file assigned 
        if self.star_file != '':
            print(" !! ERROR :: More than one star file was detected as input! (e.g. %s, %s)" % (self.star_file, f))
            exit()
        else:
            ## check the star file input exists 
            if os.path.exists(f):
                self.star_file = f

                ## after assigning it, generate a related output file 
                self.create_output_file()
            else:
                print(" !! ERROR :: Input star file (%s) does not exist! Check path carefully " % f)
                exit()
        return 

    def assign_optics_remap_file(self, f):
        ## sanity check we did not already have a file assigned 
        if self.optics_remap_file != '':
            print(" !! ERROR :: More than one optics remapping file was detected as input! (e.g. %s, %s)" % (self.optics_remap_file, f))
            exit()
        else:
            ## check the star file input exists 
            if os.path.exists(f):
                self.optics_remap_file = f
            else:
                print(" !! ERROR :: Input optics remapping file (%s) does not exist! Check path carefully " % f)
                exit()
        return 

    def create_output_file(self):
        fpath, fname = os.path.split(self.star_file)
        fbasename, fext = os.path.splitext(fname)
        outbasename = fbasename + "_REMAPPED.star"
        new_full_output_name = os.path.join(fpath, outbasename)
        self.output_star_file = new_full_output_name
        return 
    
    def __str__(self):
        print("=============================")
        print("  PARAMETERS")
        print("-----------------------------")
        print("   optics input file = %s" % self.optics_remap_file)
        print("   input star file = %s" % self.star_file)
        print("   output star file name = %s " % self.output_star_file)
        print("=============================")
        return ''
#endregion

#############################
#region     RUN BLOCK
#############################

if __name__ == "__main__":
    
    import star_handler
    import os, sys

    params = parse_cmdline(sys.argv)
    if DEBUG:
        print(params)

    ## generate a dictionary mapping each micrograph to an optics string
    ## e.g. { 'mic_name' : 'optics_code', ... } 
    mics_to_optics_dict, optics_group_list = parse_optics_remap_file(params.optics_remap_file)

    update_optics_table(params.star_file, params.output_star_file, optics_group_list)

    update_particles(params.star_file, params.output_star_file, optics_group_list, mics_to_optics_dict)

#endregion